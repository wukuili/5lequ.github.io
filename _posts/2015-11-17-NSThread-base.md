---
layout: post
title: 多线程基础知识
description: “对于”nonatomic和atomic及县城安全的一些解释”
tags: [多线程,NSThread,nonatomic]
image:
  background: 
comments: true
share: true
---

/**
 卖票问题使用加锁，互斥锁
 加锁，锁定的代码尽量少。
 加锁范围内的代码， 同一时间只允许一个线程执行
 互斥锁的参数:任何继承 NSObject *对象都可以。
 要保证这个锁，所有的线程都能访问到, 而且是所有线程访问的是同一个锁对象
 */
-----------------------------------------------------------------
 nonatomic 非原子属性
 atomic 原子属性--默认属性
 原子属性就是针对多线程设计的。 原子属性实现 单(线程)写 多(线程)读
 "atomic(原子属性)在set方法内部加了一把自旋锁"
 "nonatomic（非原子属性）下，set和get方法都不会加锁"
// 原子属性内部使用的 自旋锁
// 自旋锁和互斥锁
// 共同点: 都可以锁定一段代码。 同一时间， 只有线程能够执行这段锁定的代码
// 区别：互斥锁，在锁定的时候，其他线程会睡眠，等待条件满足，再唤醒
// 自旋锁，在锁定的时候， 其他的线程会做死循环，一直等待这条件满足，一旦条件满足，立马去执行，少了一个唤醒过程

-----------------------------------------------------------------

 线程安全的概念: 就是在多个线程同时执行的时候，能够保证资源信息的准确性.
 
 "UI线程" -- 主线程
 ** UIKit 中绝对部分的类，都不是”线程安全“的
 
 "iOS里面是怎么解决这个线程不安全的问题？"
 苹果约定，所有程序的更新UI都在主线程进行，也就不会出现多个线程同时改变一个资源。
 
 // 在主线程更新UI，有什么好处？
 1. 只在主线程更新UI，就不会出现多个线程同时改变 同一个UI控件
 2. 主线程的优先级最高。也就意味UI的更新优先级高。 会让用户感觉很流畅

